Analyze codebase; infer language/framework/paradigm from context; apply universal software engineering principles; optimize toward theoretical and practical excellence.

Detection: parse syntax/semantics; identify paradigm (imperative|declarative|functional|OOP|logic|concurrent); classify type system (Hindley-Milner|nominal|structural|dependent); recognize computational model (Turing machine|lambda calculus|actor model|pi calculus); extract architectural patterns; identify domain constraints.

Theoretical foundations: minimize time complexity (Ω,Θ,O notation); minimize space complexity; prove correctness via invariants; ensure termination; maintain referential transparency where possible; preserve equational reasoning; apply Church-Rosser confluence; implement proper abstraction boundaries; maintain information hiding; apply Liskov substitution; ensure type safety; implement parametric polymorphism; apply higher-order abstractions; use algebraic data types; implement monadic composition where appropriate; apply category theory principles (functors,monads,applicatives); maintain denotational semantics clarity.

Algorithmic optimization: replace brute force with divide-and-conquer; apply dynamic programming to overlapping subproblems; use greedy algorithms for optimal substructure; implement appropriate data structures (self-balancing trees,hash tables with good collision resolution,heaps,graphs,tries); apply graph algorithms (Dijkstra,Bellman-Ford,Floyd-Warshall,topological sort); use probabilistic data structures (Bloom filters,HyperLogLog,Count-Min sketch); implement efficient string algorithms (KMP,Rabin-Karp,suffix arrays); apply computational geometry algorithms; use amortized analysis; implement cache-oblivious algorithms; consider parallel algorithms; apply approximation algorithms for NP-hard problems.

Design principles: apply SOLID (single responsibility,open-closed,Liskov substitution,interface segregation,dependency inversion); implement separation of concerns; enforce loose coupling; maximize cohesion; apply information expert principle; apply low representational gap; use dependency injection; implement inversion of control; apply Hollywood principle; use law of Demeter; implement tell-don't-ask; apply GRASP patterns (creator,controller,pure fabrication,indirection,polymorphism,protected variations); minimize connascence; reduce coupling types (content<common<control<stamp<data); maximize interface segregation.

Architectural patterns: apply appropriate style (layered|hexagonal|onion|clean|microkernel|event-driven|microservices|serverless|CQRS|event sourcing); implement proper module boundaries; apply strategic DDD (bounded contexts,context maps,ubiquitous language); use tactical DDD (entities,value objects,aggregates,repositories,domain events,services); implement proper service boundaries; apply CAP theorem awareness; implement eventual consistency where appropriate; use saga pattern for distributed transactions; apply strangler fig for legacy migration; implement anti-corruption layer; use published language; apply shared kernel carefully.

Correctness assurance: implement design-by-contract (preconditions,postconditions,invariants); apply formal methods where critical; use type systems to prove properties; implement property-based testing (QuickCheck-style); apply model checking; use theorem provers; implement symbolic execution; apply abstract interpretation; use static analysis; implement dependent types where language supports; apply refinement types; use linear types for resource management; implement session types for protocols; apply gradual typing; use effect systems.

Concurrency correctness: apply happens-before relationships; ensure sequential consistency where needed; implement proper synchronization primitives; avoid data races; prevent deadlocks (lock ordering,timeouts,detection); avoid livelocks; ensure progress properties (lock-freedom,wait-freedom,obstruction-freedom); implement proper memory models (acquire-release,sequential consistency); use software transactional memory; apply actor model; implement CSP correctly; use async/await properly; apply reactive programming; implement proper backpressure.

Information theory: minimize entropy in data representation; apply compression where appropriate; use error-correcting codes; implement proper checksums (CRC,cryptographic hashes); apply information-theoretic security; use perfect forward secrecy; implement proper randomness sources; apply entropy pooling; use key derivation functions; implement proper nonce generation; apply probabilistic encryption.

Computational complexity awareness: identify P,NP,NP-complete,NP-hard problems; apply reduction proofs; use approximation algorithms for intractable problems; implement heuristics with bounds; apply constraint satisfaction techniques; use SAT/SMT solvers; implement proper search strategies (BFS,DFS,A*,IDA*); apply game-theoretic algorithms (minimax,alpha-beta); use dynamic programming; apply memoization; implement proper recursion (tail-call optimization).

Formal verification: specify invariants; prove loop termination; apply Hoare logic; use weakest precondition calculus; implement proof-carrying code; apply abstract interpretation; use model checking for finite-state systems; implement runtime verification; apply symbolic execution; use SMT solvers for constraint solving; implement rely-guarantee reasoning; apply separation logic for heap reasoning.

System-level optimization: minimize cache misses (spatial/temporal locality); align data structures; use SIMD instructions; implement lock-free data structures; apply memory prefetching; use appropriate memory ordering; implement proper thread scheduling; apply work-stealing; use false sharing avoidance; implement proper syscall batching; apply zero-copy techniques; use memory-mapped I/O; implement proper DMA usage.

Meta-principles: apply Occam's razor; implement YAGNI; avoid premature optimization (measure first); apply Amdahl's law awareness; consider Gustafson's law for parallelism; implement proper abstraction levels; use appropriate formalism; apply semantic versioning; implement proper deprecation; use feature flags; apply gradual migration; implement proper monitoring (observability via metrics,logs,traces); use structured logging; apply correlation IDs; implement distributed tracing.

Output: refactored code maintaining semantic equivalence; complexity analysis (worst,average,amortized); proof sketches for critical invariants; architecture diagram; identified trade-offs; remaining technical debt; theoretical limitations; recommended literature.

Meta: preserve program semantics (denotational equivalence); maintain backward compatibility unless breaking changes justified by significant theoretical improvement; prioritize correctness>performance>maintainability; prove optimizations valid; flag undecidable properties; cite relevant theory (papers,textbooks,algorithms).

