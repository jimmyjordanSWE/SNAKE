STRUCTURE
fuzz
 fuzz_net.c
  f LLVMFuzzerTestOneInput(*data,size)
 fuzz_persist.c
  f LLVMFuzzerTestOneInput(*data,size)
 fuzz_stb_image.c
  f LLVMFuzzerTestOneInput(*data,size)
include
 snake
  collision.h
   f collision_
    detect_and_resolve(*game)
    is_
     self(p,*player)
     snake(p,*player)
     wall(p,board_w,board_h)
    next_head(current,dir)
   s GameState
   s PlayerState
  console.h
   f console_
    box_
     paused_terminal_small(term_w,term_h,req_w,req_h)
     too_small_for_game(term_w,term_h,min_w,min_h)
    error(*fmt)
    game_ran(ticks)
    info(*fmt)
    terminal_resized(w,h)
    warn(*fmt)
  direction.h
   f snake_dir_turn_
    left(d)
    right(d)
  display.h
   f display_
    clear(*ctx)
    draw_line_
     h(*ctx,x,y,len,ch,fg,bg)
     v(*ctx,x,y,len,ch,fg,bg)
    fill_rect(*ctx,x,y,w,h,ch,fg,bg)
    flush(*ctx)
    force_redraw(*ctx)
    get_size(*ctx,*width,*height)
    present(*ctx)
    put_
     char(*ctx,x,y,ch,fg,bg)
     hline(*ctx,x,y,len,ch,fg,bg)
     string(*ctx,x,y,*str,fg,bg)
     vline(*ctx,x,y,len,ch,fg,bg)
    shutdown(*ctx)
    size_valid(*ctx)
   s DisplayContext
   t DisplayContext
  env.h
   f env_bool(*name,default_val)
  game.h
   f game_
    destroy(*g)
    enqueue_input(*g,player_index,*in)
    get_
     num_players(*g)
     size(*g,*width,*height)
     status(*g)
    player_
     current_score(*g,player_index)
     died_this_tick(*g,player_index)
     is_active(*g,player_index)
     score_at_death(*g,player_index)
    reset(*g)
    step(*g,*out_events)
   s <anon>{GAME_EVENTS_MAX_PLAYERS,GAME_EVENTS_MAX_PLAYERS,died_count,game_over,food_respawned}
   s Game
   s GameState
   s PlayerState
   t Game
   t GameEvents
   t GameState
   t PlayerState
  input.h
   f input_
    init(_)
    poll(*out)
    poll_from_buf(*out,*buf,n)
    set_key_bindings(up,down,turn_left,turn_right,quit,restart,pause_toggle)
    shutdown(_)
   s <anon>{quit,any_key,move_up,turn_left}
   t InputState
  net.h
   f net_
    disconnect(*client)
    free_unpacked_game_state(*out)
    pack_
     game_state(*game,*buf,buf_size)
     input(*input,*buf,buf_size)
    recv_state(*client,*out_game)
    send_input(*client,*input)
    unpack_
     game_state(*buf,buf_size,*out)
     input(*buf,buf_size,*out)
   s NetClient
   t NetClient
  persist.h
   f game_config_
    destroy(*cfg)
    get_
     active_player(*cfg)
     board_size(*cfg,*w_out,*h_out)
     enable_external_3d_view(*cfg)
     floor_texture_scale(*cfg)
     fov_degrees(*cfg)
     key_
      down(*cfg)
      left(*cfg)
      pause(*cfg)
      quit(*cfg)
      restart(*cfg)
      right(*cfg)
      up(*cfg)
     max_
      food(*cfg)
      length(*cfg)
      players(*cfg)
     num_players(*cfg)
     render_glyphs(*cfg)
     screen_size(*cfg,*w_out,*h_out)
     seed(*cfg)
     show_sprite_debug(*cfg)
     tail_height_scale(*cfg)
     tick_rate_ms(*cfg)
     wall_
      height_scale(*cfg)
      texture_scale(*cfg)
    set_
     active_player(*cfg,v)
     board_size(*cfg,w,h)
     enable_external_3d_view(*cfg,v)
     floor_
      texture(*cfg,*path)
      texture_scale(*cfg,v)
     fov_degrees(*cfg,fov)
     key_
      down(*cfg,c)
      left(*cfg,c)
      pause(*cfg,c)
      quit(*cfg,c)
      restart(*cfg,c)
      right(*cfg,c)
      up(*cfg,c)
     max_
      food(*cfg,v)
      length(*cfg,v)
      players(*cfg,n)
     num_players(*cfg,n)
     player_name(*cfg,*name)
     render_glyphs(*cfg,v)
     screen_size(*cfg,w,h)
     seed(*cfg,seed)
     show_sprite_debug(*cfg,v)
     tail_height_scale(*cfg,v)
     tick_rate_ms(*cfg,ms)
     wall_
      height_scale(*cfg,v)
      texture(*cfg,*path)
      texture_scale(*cfg,v)
   f highscore_
    destroy(*hs)
    get_score(*hs)
    set_
     name(*hs,*name)
     score(*hs,score)
   f persist_
    append_score(*filename,*name,score)
    config_has_unknown_keys(*filename)
    free_scores(*scores,count)
    load_config(*filename,*out_config)
    read_scores(*filename,*out_scores)
    write_
     config(*filename,*config)
     scores(*filename,*scores,count)
   s GameConfig
   s HighScore
   t GameConfig
   t HighScore
  platform.h
   f platform_
    get_terminal_size(*width_out,*height_out)
    now_ms(_)
    sleep_ms(ms)
    was_resized(_)
    winch_init(_)
  render.h
   f render_
    draw(*game,*player_name,*scores,score_count)
    draw_
     death_overlay(*game,anim_frame,show_prompt)
     startup_screen(*player_name_out,max_len)
    init(min_width,min_height)
    note_session_score(*name,score)
    prompt_for_highscore_name(*player_name_out,max_len,score)
    set_glyphs(glyphs)
    shutdown(_)
   t RenderGlyphs
  render_3d.h
   f render_3d_
    compute_minimap_cell_px(display_w,display_h,map_w,map_h)
    draw(*game_state,*player_name,*scores,score_count,delta_seconds)
    draw_
     congrats_overlay(score,*name_entered)
     death_overlay(*game,anim_frame,show_prompt)
     minimap_into(*ctx,*gs)
    init(*game_state,*config)
    on_tick(*game_state)
    set_
     active_player(player_index)
     fov(fov_degrees)
     tick_rate_ms(ms)
    shutdown(_)
   s <anon>{active_player,fov_degrees,show_sprite_debug,screen_width,screen_height,wall_height_scale,tail_height_scale,wall_texture_scale,floor_texture_scale,PERSIST_TEXTURE_PATH_MAX,PERSIST_TEXTURE_PATH_MAX}
   s SDL3DContext
   t Render3DConfig
  render_3d_camera.h
   f camera_
    camera_to_world(*camera,cam_x,cam_y,*world_x_out,*world_y_out)
    destroy(*camera)
    distance_to_point(*camera,x,y)
    get_
     dir(*cam,*dx_out,*dy_out)
     fov_radians(*cam)
     interp_time(*cam)
     interpolated_
      angle(*camera)
      position(*camera,*x_out,*y_out)
     interpolation_fraction(*cam)
     position(*cam,*x_out,*y_out)
     ray_angle(*camera,col,*ray_angle_out)
     update_interval(*cam)
    init(*camera,fov_degrees,screen_width,update_interval)
    point_in_front(*camera,x,y)
    set_
     angle(*cam,angle)
     from_player(*camera,x,y,dir)
     interpolation_time(*camera,time)
     position(*cam,x,y)
     prev_
      angle(*cam,prev_angle)
      position(*cam,prev_x,prev_y)
     update_interval(*cam,update_interval)
    update_
     interpolation(*camera,delta_time)
     vectors(*camera)
    world_to_camera(*camera,world_x,world_y,*cam_x_out,*cam_y_out)
   s Camera3D
   t Camera3D
  render_3d_display.h
   f display_3d_
    clear(*disp,ch,color)
    destroy(*disp)
    draw_
     cell(*disp,x,y,ch,color)
     column(*disp,col,start_row,end_row,ch,color)
     row(*disp,row,start_col,end_col,ch,color)
    get_
     height(*disp)
     width(*disp)
    init(*disp,width,height)
    present(*disp)
    shutdown(*disp)
   s <anon>{character,color}
   s Display3D
   t Display3D
   t Framebuffer3DCell
  render_3d_perspective.h
   f render_3d_compute_wall_u(interp_cam_x,interp_cam_y,ray_angle,yy,horizon,screen_height,pd,is_vertical,wall_world_height,*out_rowDist)
  render_3d_projection.h
   f projection_
    destroy(*proj)
    get_
     fov_radians(*proj)
     screen_
      height(*proj)
      width(*proj)
     wall_scale(*proj)
    init(*proj,screen_width,screen_height,fov_radians,wall_scale)
    project_
     wall(*proj,distance,*result_out)
     wall_perp(*proj,distance,ray_angle,cam_angle,*result_out)
    set_horizon(*proj,horizon_y)
    world_distance_per_
     pixel(*proj,distance)
     pixel_perp(*proj,distance,ray_angle,cam_angle)
   s <anon>{draw_start,draw_end,wall_height,texture_scale}
   s Projection3D
   t Projection3D
   t WallProjection
  render_3d_raycast.h
   f raycast_
    cast_ray(*rc,camera_x,camera_y,ray_angle,*hit_out)
    get_texture_coord(*hit,is_vertical)
    init(*rc,width,height,*board)
    is_wall(*rc,x,y)
   f raycaster_destroy(*rc)
   s <anon>{distance,hit_x,hit_y,is_vertical,shade_level}
   s Raycaster3D
   t RayHit
   t Raycaster3D
  render_3d_sdl.h
   f render_3d_sdl_
    blend_pixel(*ctx,x,y,src_col)
    clear(*ctx,col)
    color(r,g,b,a)
    destroy(*ctx)
    draw_
     column(*ctx,x,y_start,y_end,col)
     filled_
      circle(*ctx,center_x,center_y,radius,col)
      rect(*ctx,x,y,w,h,col)
    get_
     height(*ctx)
     width(*ctx)
    init(width,height,*ctx_out)
    present(*ctx)
    set_pixel(*ctx,x,y,col)
    shutdown(*ctx)
   s SDL3DContext
   t SDL3DContext
  render_3d_sprite.h
   f sprite_
    add(*sr,world_x,world_y,world_height,pivot,face_camera,texture_id,frame)
    add_
     color(*sr,world_x,world_y,world_height,pivot,face_camera,texture_id,frame,color)
     rect_color(*sr,world_x,world_y,world_height,pivot,face_camera,texture_id,frame,color)
    clear(*sr)
    destroy(*sr)
    draw(*sr,*ctx,*column_depths)
    get_
     count(*sr)
     screen_info(*sr,idx,*screen_x_out,*screen_h_out,*visible_out)
     texture_id(*sr,idx,*texture_id_out)
    init(*sr,max_sprites,*camera,*proj)
    project_all(*sr)
    shutdown(*sr)
    sort_by_depth(*sr)
   s Sprite3D
   s SpriteRenderer3D
   t Sprite3D
   t SpriteRenderer3D
  render_3d_texture.h
   f texture_
    destroy(*tex)
    free_image(*tex)
    get_
     img_
      h(*tex)
      w(*tex)
     texel(*tex,distance,is_vertical,tex_coord,*texel_out)
    has_image(*tex)
    init(*tex)
    load_from_file(*tex,*filename)
    sample(*tex,u,v,bilinear)
    set_shade_
     chars(*tex,*chars)
     colors(*tex,*colors)
    shade_from_distance(distance)
   s <anon>{color}
   s Texture3D
   t Texel
   t Texture3D
  render_input.h
   f render_sanitize_player_name(*input,*out,out_len)
  snakegame.h
   f snake_game_
    free(*game)
    run(*game)
   s SnakeGame
   t SnakeGame
  tty.h
   f tty_
    check_resize(*ctx)
    clear_
     back(*ctx)
     front(*ctx)
    close(*ctx)
    flip(*ctx)
    force_redraw(*ctx)
    get_
     board_min_size(board_width,board_height,*min_width,*min_height)
     min_size(*ctx,*min_width,*min_height)
     pixel(*ctx,x,y)
     size(*ctx,*width,*height)
     write_buffer_size(*ctx)
    put_pixel(*ctx,x,y,px)
    set_
     resize_callback(*ctx,*callback,*userdata)
     size_invalid_callback(*ctx,*callback,*userdata)
    size_
     sufficient_for_board(term_width,term_height,board_width,board_height)
     valid(*ctx)
   s ascii_pixel
    {pixel,color}
    
   s tty_context
   t tty_context
  types.h
   s <anon>{x}
   t GameStatus
   t SnakeDir
   t SnakePoint
  utils.h
   f snake_
    in_bounds(x,y,width,height)
    rng_
     next_u32(*state)
     range(*state,lo,hi_inclusive)
     seed(*state,seed)
  validate.h
   f safe_
    copy_and_null(*dst,dst_size,*src,len)
    snprintf(*buf,buf_size,*fmt)
main.c
 f main(_)
src
 console
  console.c
   f console_
    box_
     paused_terminal_small(term_w,term_h,req_w,req_h)
     too_small_for_game(term_w,term_h,min_w,min_h)
    error(*fmt)
    game_ran(ticks)
    info(*fmt)
    terminal_resized(w,h)
    warn(*fmt)
 core
  collision.c
   f collision_
    detect_and_resolve(*game)
    is_
     self(p,*player)
     snake(p,*player)
     wall(p,board_w,board_h)
    next_head(current,dir)
  game.c
   f food_respawn(*game)
   f game_
    destroy(*g)
    enqueue_input(*g,player_index,*in)
    free(*game)
    get_
     num_players(*g)
     size(*g,*width,*height)
     status(*g)
    init(*game,width,height,*cfg)
    player_
     current_score(*g,player_index)
     died_this_tick(*g,player_index)
     is_active(*g,player_index)
     score_at_death(*g,player_index)
    reset(*g)
    state_
     get_num_players(*game)
     player_
      current_score(*game,player_index)
      died_this_tick(*game,player_index)
      is_active(*game,player_index)
      score_at_death(*game,player_index)
     reset(*game)
    step(*g,*out_events)
    tick(*game)
   f opposite_dir(dir)
   f player_move(*player,next_head,grow)
   f point_
    in_
     any_snake(*game,p)
     player(*player,p)
    is_food(*game,p)
   f random_point(*game)
   f spawn_player(*game,player_index)
   s Game{state}
  game_internal.h
   f game_
    free(*game)
    init(*game,width,height,*cfg)
    tick(*game)
   s GameState{width,rng_state,status,num_players,max_players,*food,food_count,max_food,last_food_respawned,*players,max_length}
   s PlayerState{current_dir,score,died_this_tick,score_at_death,*body,length,max_length,active,prev_head_x,prev_head_y,*prev_segment_x,*prev_segment_y}
 input
  input.c
   f ascii_tolower(c)
   f input_
    init(_)
    poll(*out)
    poll_from_buf(*out,*buf,n)
    set_key_bindings(up,down,turn_left,turn_right,quit,restart,pause_toggle)
    shutdown(_)
   f parse_arrow_key(code)
   f restore_terminal(_)
   s termios
 net
  net.c
   f net_
    disconnect(*client)
    free_unpacked_game_state(*out)
    pack_
     game_state(*game,*buf,buf_size)
     input(*input,*buf,buf_size)
    recv_state(*client,*out_game)
    send_input(*client,*input)
    unpack_
     game_state(*buf,buf_size,*out)
     input(*buf,buf_size,*out)
   s NetClient{fd}
 persist
  persist.c
   f clamp_int(v,lo,hi)
   f compare_scores(*a,*b)
   f game_config_
    destroy(*cfg)
    get_
     active_player(*cfg)
     board_size(*cfg,*w_out,*h_out)
     enable_external_3d_view(*cfg)
     floor_texture_scale(*cfg)
     fov_degrees(*cfg)
     key_
      down(*cfg)
      left(*cfg)
      pause(*cfg)
      quit(*cfg)
      restart(*cfg)
      right(*cfg)
      up(*cfg)
     max_
      food(*cfg)
      length(*cfg)
      players(*cfg)
     num_players(*cfg)
     render_glyphs(*cfg)
     screen_size(*cfg,*w_out,*h_out)
     seed(*cfg)
     show_sprite_debug(*cfg)
     tail_height_scale(*cfg)
     tick_rate_ms(*cfg)
     wall_
      height_scale(*cfg)
      texture_scale(*cfg)
    set_
     active_player(*cfg,v)
     board_size(*cfg,w,h)
     enable_external_3d_view(*cfg,v)
     floor_
      texture(*cfg,*path)
      texture_scale(*cfg,v)
     fov_degrees(*cfg,fov)
     key_
      down(*cfg,c)
      left(*cfg,c)
      pause(*cfg,c)
      quit(*cfg,c)
      restart(*cfg,c)
      right(*cfg,c)
      up(*cfg,c)
     max_
      food(*cfg,v)
      length(*cfg,v)
      players(*cfg,n)
     num_players(*cfg,n)
     player_name(*cfg,*name)
     render_glyphs(*cfg,v)
     screen_size(*cfg,w,h)
     seed(*cfg,seed)
     show_sprite_debug(*cfg,v)
     tail_height_scale(*cfg,v)
     tick_rate_ms(*cfg,ms)
     wall_
      height_scale(*cfg,v)
      texture(*cfg,*path)
      texture_scale(*cfg,v)
   f highscore_
    destroy(*hs)
    get_score(*hs)
    set_
     name(*hs,*name)
     score(*hs,score)
   f is_known_config_key(*key)
   f persist_
    append_score(*filename,*name,score)
    config_has_unknown_keys(*filename)
    free_scores(*scores,count)
    load_config(*filename,*out_config)
    read_scores(*filename,*out_scores)
    write_
     config(*filename,*config)
     scores(*filename,*scores,count)
   s GameConfig{board_width,tick_rate_ms,render_glyphs,screen_width,enable_external_3d_view,seed,fov_degrees,show_sprite_debug,active_player,num_players,PERSIST_PLAYER_NAME_MAX,max_players,max_length,max_food,wall_height_scale,tail_height_scale,wall_texture_scale,floor_texture_scale,PERSIST_TEXTURE_PATH_MAX,PERSIST_TEXTURE_PATH_MAX,key_up,key_down,key_left,key_right,key_quit,key_restart,key_pause}
   s HighScore{PERSIST_NAME_MAX,score}
 platform
  platform.c
   f platform_
    get_terminal_size(*width_out,*height_out)
    now_ms(_)
    sigwinch_handler(sig)
    sleep_ms(ms)
    was_resized(_)
    winch_init(_)
  tty.c
   f ascii_pixel_equal(a,b)
   f get_terminal_size(fd,*width,*height)
   f sigwinch_handler(sig)
   f tty_
    check_resize(*ctx)
    clear_
     back(*ctx)
     front(*ctx)
    close(*ctx)
    flip(*ctx)
    force_redraw(*ctx)
    get_
     board_min_size(board_width,board_height,*min_width,*min_height)
     min_size(*ctx,*min_width,*min_height)
     pixel(*ctx,x,y)
     size(*ctx,*width,*height)
     write_buffer_size(*ctx)
    put_pixel(*ctx,x,y,px)
    set_
     resize_callback(*ctx,*callback,*userdata)
     size_invalid_callback(*ctx,*callback,*userdata)
    size_
     sufficient_for_board(term_width,term_height,board_width,board_height)
     valid(*ctx)
   f utf16_
    surrogate_pair_to_utf8(high,low,*out)
    to_utf8(utf16,*utf8_out)
   s ascii_pixel
   s tty_context{tty_fd,orig_termios,tty_path,width,height,min_width,min_height,*front,*back,dirty,size_valid,*write_buffer,write_buffer_size,resized,*on_resize,*on_size_invalid,*callback_userdata}
 render
  camera.c
   f angle_difference(from,to)
   f camera_
    camera_to_world(*camera,cam_x,cam_y,*world_x_out,*world_y_out)
    destroy(*camera)
    distance_to_point(*camera,x,y)
    get_
     dir(*cam,*dx_out,*dy_out)
     fov_radians(*cam)
     interp_time(*cam)
     interpolated_
      angle(*camera)
      position(*camera,*x_out,*y_out)
     interpolation_fraction(*cam)
     position(*cam,*x_out,*y_out)
     ray_angle(*camera,col,*ray_angle_out)
     update_interval(*cam)
    init(*camera,fov_degrees,screen_width,update_interval)
    point_in_front(*camera,x,y)
    set_
     angle(*cam,angle)
     from_player(*camera,x,y,dir)
     interpolation_time(*camera,time)
     position(*cam,x,y)
     prev_
      angle(*cam,prev_angle)
      position(*cam,prev_x,prev_y)
     update_interval(*cam,update_interval)
    update_
     interpolation(*camera,delta_time)
     vectors(*camera)
    world_to_camera(*camera,world_x,world_y,*cam_x_out,*cam_y_out)
   f interpolate_angle(from,to,t)
   f normalize_angle(angle)
   f update_vectors(*camera)
   s Camera3D{x,angle,prev_x,fov_radians,screen_width,dir_x,plane_x,interp_time,update_interval}
  display_3d.c
   f display_3d_
    clear(*disp,ch,color)
    destroy(*disp)
    draw_
     cell(*disp,x,y,ch,color)
     column(*disp,col,start_row,end_row,ch,color)
     row(*disp,row,start_col,end_col,ch,color)
    get_
     height(*disp)
     width(*disp)
    init(*disp,width,height)
    present(*disp)
    shutdown(*disp)
   s Display3D{width,height,*buffer}
  display_tty.c
   f display_
    clear(*ctx)
    force_redraw(*ctx)
    get_size(*ctx,*width,*height)
    present(*ctx)
    put_
     char(*ctx,x,y,ch,fg,bg)
     hline(*ctx,x,y,len,ch,fg,bg)
     string(*ctx,x,y,*str,fg,bg)
     vline(*ctx,x,y,len,ch,fg,bg)
    shutdown(*ctx)
    size_valid(*ctx)
   f map_color(display_color)
   s DisplayContext{*tty}
  internal
   render_3d_sprite_internal.h
    s Sprite3D{world_x,world_height,pivot,face_camera,texture_id,frame,color,perp_distance,screen_x,screen_w,screen_h,screen_y_top,visible,is_rect}
  projection.c
   f projection_
    destroy(*proj)
    get_
     fov_radians(*proj)
     screen_
      height(*proj)
      width(*proj)
     wall_scale(*proj)
    init(*proj,screen_width,screen_height,fov_radians,wall_scale)
    project_
     wall(*proj,distance,*result_out)
     wall_perp(*proj,distance,ray_angle,cam_angle,*out)
    set_horizon(*proj,horizon_y)
    world_distance_per_
     pixel(*proj,distance)
     pixel_perp(*proj,distance,ray_angle,cam_angle)
   s Projection3D{screen_width,screen_height,fov_radians,horizon_y,wall_scale}
  raycast.c
   f raycast_
    cast_ray(*rc,camera_x,camera_y,ray_angle,*hit_out)
    get_texture_coord(*hit,is_vertical)
    init(*rc,width,height,*board)
    is_wall(*rc,x,y)
   f raycaster_destroy(*rc)
   s Raycaster3D{board_width,board_height,*board}
  render.c
   f compare_display_scores_desc(*a,*b)
   f draw_
    box(x,y,width,height,fg_color)
    centered_string(y,*str,fg_color)
    string(x,y,*str,fg_color)
    top_bar(_)
   f fill_
    background(_)
    rect(x,y,width,height,fg_color,bg_color,ch)
   f glyph_for_
    segment(*body,length,idx)
    segment_
     ascii(*body,length,idx)
     utf8(*body,length,idx)
   f gradient_color_for_rank(rank,total)
   f invalidate_front_buffer(*ctx)
   f is_session_
    score(*s)
    score_from_display(*s)
   f links_to_neighbor(from,neighbor)
   f render_
    draw(*game,*player_name,*scores,score_count)
    draw_
     death_overlay(*game,anim_frame,show_prompt)
     startup_screen(*player_name_out,max_len)
    init(min_width,min_height)
    note_session_score(*name,score)
    prompt_for_highscore_name(*player_name_out,max_len,score)
    set_glyphs(glyphs)
    shutdown(_)
   s <anon>
    {PERSIST_NAME_MAX,score}
    {up,down,left,right}
   t DisplayScore
   t SegmentLinks
  render_3d.c
   f render_3d_
    compute_minimap_cell_px(d_w,d_h,m_w,m_h)
    draw(*game_state,*player_name,*scores,score_count,delta_seconds)
    draw_
     char(*disp,x,y,c,col,scale)
     congrats_overlay(score,*name_entered)
     death_overlay(*game,anim_frame,show_prompt)
     fps_counter(_)
     minimap(*r,interp_t)
     minimap_into(*ctx,*gs)
     text_centered(*disp,y,*text,col,scale)
    init(*game_state,*config)
    log(*fmt)
    on_tick(*game_state)
    set_
     active_player(player_index)
     fov(fov_degrees)
     tick_rate_ms(ms)
    shutdown(_)
    update_fps(delta_seconds)
   s <anon>{*game_state,*camera,*raycaster,*projector,*texture,*wall_texture,*floor_texture,*sprite_renderer,*display,config,initialized,*column_depths,frame_times,frame_time_idx,current_fps}
   s SDL3DContext
   t Render3DContext
   t RenderMode
  render_3d_sdl.c
   f call_lsan_
    disable(_)
    enable(_)
   f render_3d_sdl_
    blend_pixel(*ctx,x,y,src_col)
    clear(*ctx,col)
    destroy(*ctx)
    draw_
     column(*ctx,x,y_start,y_end,col)
     filled_
      circle(*ctx,center_x,center_y,radius,col)
      rect(*ctx,x,y,w_rect,h_rect,col)
    get_
     height(*ctx)
     width(*ctx)
    init(width,height,*ctx_out)
    present(*ctx)
    set_pixel(*ctx,x,y,col)
    shutdown(*ctx)
   s <anon>{*window,*renderer,*texture,width,height}
   s SDL3DContext{width,height,*pixels,*window,*renderer,*texture,initialized}
   t SDLState
  render_input.c
   f render_sanitize_player_name(*input,*out,out_len)
  sprite.c
   f sprite_
    add(*sr,world_x,world_y,world_height,pivot,face_camera,texture_id,frame)
    add_
     color(*sr,world_x,world_y,world_height,pivot,face_camera,texture_id,frame,color)
     rect_color(*sr,world_x,world_y,world_height,pivot,face_camera,texture_id,frame,color)
    clear(*sr)
    destroy(*sr)
    draw(*sr,*ctx,*column_depths)
    get_
     count(*sr)
     screen_info(*sr,idx,*screen_x_out,*screen_h_out,*visible_out)
     texture_id(*sr,idx,*texture_id_out)
    init(*sr,max_sprites,*camera,*proj)
    project_all(*sr)
    shutdown(*sr)
    sort_by_depth(*sr)
   s SpriteRenderer3D{*sprites,max_sprites,count,*camera,*proj}
  texture.c
   f is_safe_texture_filename(*filename)
   f sample_
    bilinear(*tex,u,v)
    nearest(*tex,u,v)
   f texture_
    destroy(*tex)
    free_image(*tex)
    get_
     img_
      h(*tex)
      w(*tex)
     texel(*tex,distance,is_vertical,tex_coord,*texel_out)
    has_image(*tex)
    init(*tex)
    load_from_file(*tex,*filename)
    sample(*tex,u,v,bilinear)
    set_shade_
     chars(*tex,*chars)
     colors(*tex,*colors)
    shade_from_distance(distance)
   s Texture3D{TEXTURE_MAX_SHADES,TEXTURE_MAX_SHADES,*pixels,img_w,img_h}
  wall_perspective.c
   f render_3d_compute_wall_u(interp_cam_x,interp_cam_y,ray_angle,yy,horizon,screen_height,pd,is_vertical,wall_world_height,*out_rowDist)
 snakegame.c
  f snake_game_
   free(*s)
   run(*s)
  s SnakeGame{*cfg,*game,has_3d}
 utils
  bounds.c
   f snake_in_bounds(x,y,width,height)
  direction.c
   f snake_dir_turn_
    left(d)
    right(d)
  env.c
   f env_bool(*name,default_val)
  rng.c
   f snake_rng_
    next_u32(*state)
    range(*state,lo,hi_inclusive)
    seed(*state,seed)
  utils.c
  validate.c
   f safe_
    copy_and_null(*dst,dst_size,*src,len)
    snprintf(*buf,buf_size,*fmt)
tests
 test_collision.c
  f main(_)
 test_env.c
  f main(_)
 test_game_oom.c
  f ensure_real_fns(_)
  f free(*p)
  f main(_)
 test_highscore_name.c
  f main(_)
 test_input.c
  f main(_)
 test_net.c
  f main(_)
 test_net_integration.c
  f main(_)
 test_net_overflow.c
  f main(_)
 test_persist.c
  f main(_)
  f run_case(*content,expect_count)
 test_persist_config.c
  f main(_)
  f run_case(*content,expect_ok)
 test_persist_long_lines.c
  f main(_)
  f run_case(*fn)
 test_persist_truncation.c
  f main(_)
 test_stb_artifacts.c
  f main(_)
 test_stb_chunk_size_limit.c
  f main(_)
 test_stb_image_fuzz.c
  f main(_)
 test_stb_leak_plte.c
  f main(_)
 test_texture_path.c
  f main(_)
 test_texture_path_extra.c
  f main(_)
 test_tty_buffer_cap.c
  f main(_)
 test_tty_path.c
  f main(_)
